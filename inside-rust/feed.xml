<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/inside-rust/" version="0.1.0">Inside Rust Blog</generator>
    <link href="https://blog.rust-lang.org/inside-rust/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/inside-rust/" rel="alternate" type="text/html" />
    <id>https://blog.rust-lang.org/inside-rust/</id>
    <title>Inside Rust Blog</title>
    <subtitle>Want to follow along with Rust development? Curious how you might get involved? Take a look!</subtitle>
    <author>
        <name>Maintained by the Rust Teams.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>
    <updated>2023-01-20T16:25:02+00:00</updated>

    
    <entry>
        <title>1.66.0 pre-release testing</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2022/12/12/1.66.0-prerelease.html" type="text/html" title="1.66.0 pre-release testing" />
        <published>2022-12-12T00:00:00+00:00</published>
        <updated>2022-12-12T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2022/12/12/1.66.0-prerelease.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2022/12/12/1.66.0-prerelease.html">&lt;p&gt;The 1.66.0 pre-release is ready for testing. The release is scheduled for
December 15. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1660-2022-12-15&quot;&gt;Release notes can be found here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can try it out locally by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-plain&quot;&gt;RUSTUP_DIST_SERVER&#x3D;https://dev-static.rust-lang.org rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The index is &lt;a href&#x3D;&quot;https://dev-static.rust-lang.org/dist/2022-12-12/index.html&quot;&gt;https://dev-static.rust-lang.org/dist/2022-12-12/index.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can leave feedback on the &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/rust-1-66-0-pre-release-testing/17966&quot;&gt;internals thread&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The release team is also thinking about changes to our pre-release process:
we&#x27;d love your feedback &lt;a href&#x3D;&quot;https://github.com/rust-lang/release-team/issues/16&quot;&gt;on this GitHub issue&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Release automation</name>
        </author>
    </entry>
    
    <entry>
        <title>Please welcome The 8472 to the Library team</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2022/11/29/libs-member.html" type="text/html" title="Please welcome The 8472 to the Library team" />
        <published>2022-11-29T00:00:00+00:00</published>
        <updated>2022-11-29T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2022/11/29/libs-member.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2022/11/29/libs-member.html">&lt;p&gt;We&#x27;re very excited to announce that &lt;a href&#x3D;&quot;https://github.com/the8472&quot;&gt;The 8472&lt;/a&gt;
has joined &lt;a href&#x3D;&quot;https://www.rust-lang.org/governance/teams/library&quot;&gt;the Library team&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;The 8472 has been working on &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pulls?q&#x3D;is%3Apr+author%3Athe8472&quot;&gt;many optimizations and other improvements&lt;/a&gt; to the standard library,
is &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pulls?q&#x3D;involves%3Athe8472&quot;&gt;involved in many library-related changes and discussions&lt;/a&gt;,
and regularly &lt;a href&#x3D;&quot;https://github.com/search?q&#x3D;repo%3Arust-lang%2Frust+%22r%3Dthe8472%22&amp;amp;type&#x3D;commits&amp;amp;s&#x3D;committer-date&amp;amp;o&#x3D;desc&quot;&gt;reviews&lt;/a&gt; pull requests.&lt;/p&gt;
&lt;p&gt;Congratulations The 8472, and thanks for everything you do!&lt;/p&gt;
</content>

        <author>
            <name>Mara Bos</name>
        </author>
    </entry>
    
    <entry>
        <title>Async fn in trait MVP comes to nightly</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2022/11/17/async-fn-in-trait-nightly.html" type="text/html" title="Async fn in trait MVP comes to nightly" />
        <published>2022-11-17T00:00:00+00:00</published>
        <updated>2022-11-17T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2022/11/17/async-fn-in-trait-nightly.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2022/11/17/async-fn-in-trait-nightly.html">&lt;p&gt;The async working group is excited to announce that &lt;code&gt;async fn&lt;/code&gt; can now be used in traits in the nightly compiler. You can now write code like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;#![feature(async_fn_in_trait)]

trait Database {
    async fn fetch_data(&amp;amp;self) -&amp;gt; String;
}

impl Database for MyDb {
    async fn fetch_data(&amp;amp;self) -&amp;gt; String { ... }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A full working example is available in the &lt;a href&#x3D;&quot;https://play.rust-lang.org/?version&#x3D;nightly&amp;amp;mode&#x3D;debug&amp;amp;edition&#x3D;2021&amp;amp;gist&#x3D;6ffde69ba43c6c5094b7fbdae11774a9&quot;&gt;playground&lt;/a&gt;. There are some limitations we&#x27;ll cover, as well as a few known bugs to be worked out, but we think it is ready for some users to try. Read on for the specifics.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#recap-how-asyncawait-works-in-rust&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;recap-how-asyncawait-works-in-rust&quot;&gt;&lt;/a&gt;Recap: How async/await works in Rust&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;async&lt;/code&gt; and &lt;code&gt;.await&lt;/code&gt; were a major improvement in the ergonomics of writing async code in Rust. In Rust, an &lt;code&gt;async fn&lt;/code&gt; returns a &lt;code&gt;Future&lt;/code&gt;, which is some object that represents an ongoing asynchronous computation.&lt;/p&gt;
&lt;p&gt;The type of the future does not actually appear in the signature of an &lt;code&gt;async fn&lt;/code&gt;. When you write an async function like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;async fn fetch_data(db: &amp;amp;MyDb) -&amp;gt; String { ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The compiler rewrites it to something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn fetch_data&amp;lt;&#x27;a&amp;gt;(db: &amp;amp;&#x27;a MyDb) -&amp;gt; impl Future&amp;lt;Output &#x3D; String&amp;gt; + &#x27;a {
    async move { ... }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This &amp;quot;desugared&amp;quot; signature is something you can write yourself, and it&#x27;s useful for examining what goes on under the hood. The &lt;code&gt;impl Future&lt;/code&gt; syntax here represents some &lt;em&gt;opaque type&lt;/em&gt; that implements &lt;code&gt;Future&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The future is a state machine responsible for knowing how to continue making progress the next time it wakes up. When you write code in an &lt;code&gt;async&lt;/code&gt; block, the compiler generates a future type specific to that async block for you. This future type does not have a name, so we must instead use an opaque type in the function signature.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#the-historic-problem-of-async-fn-in-trait&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;the-historic-problem-of-async-fn-in-trait&quot;&gt;&lt;/a&gt;The historic problem of &lt;code&gt;async fn&lt;/code&gt; in trait&lt;/h2&gt;
&lt;p&gt;Traits are the fundamental mechanism of abstraction in Rust. So what happens if you want to put an async method in a trait? Each &lt;code&gt;async&lt;/code&gt; block or function creates a unique type, so you would want to express that each implementation can have a different Future for the return type. Thankfully, we have associated types for this:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait Database {
    type FetchData&amp;lt;&#x27;a&amp;gt;: Future&amp;lt;Output &#x3D; String&amp;gt; + &#x27;a where Self: &#x27;a;
    fn fetch_data&amp;lt;&#x27;a&amp;gt;(&amp;amp;&#x27;a self) -&amp;gt; FetchData&amp;lt;&#x27;a&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that this associated type is generic. Generic associated types haven&#x27;t been supported in the language... &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2022/10/28/gats-stabilization.html&quot;&gt;until now&lt;/a&gt;! Unfortunately though, even with GATs, you still can&#x27;t write a trait &lt;em&gt;implementation&lt;/em&gt; that uses &lt;code&gt;async&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;impl Database for MyDb {
    type FetchData&amp;lt;&#x27;a&amp;gt; &#x3D; /* what type goes here??? */;
    fn fetch_data&amp;lt;&#x27;a&amp;gt;(&amp;amp;&#x27;a self) -&amp;gt; FetchData&amp;lt;&#x27;a&amp;gt; { async move { ... } }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since you can&#x27;t name the type constructed by an async block, the only option is to use an opaque type (the &lt;code&gt;impl Future&lt;/code&gt; we saw earlier). But those are not supported in associated types!&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn1&quot; id&#x3D;&quot;fnref1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#workarounds-available-in-the-stable-compiler&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;workarounds-available-in-the-stable-compiler&quot;&gt;&lt;/a&gt;Workarounds available in the stable compiler&lt;/h3&gt;
&lt;p&gt;So to write an &lt;code&gt;async fn&lt;/code&gt; in a trait we need a concrete type to specify in our impl. There are a couple ways of achieving this today.&lt;/p&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#runtime-type-erasure&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;runtime-type-erasure&quot;&gt;&lt;/a&gt;Runtime type erasure&lt;/h4&gt;
&lt;p&gt;First, we can avoid writing the future type by erasing it with &lt;code&gt;dyn&lt;/code&gt;. Taking our example from above, you would write your trait like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait Database {
    fn fetch_data(&amp;amp;self)
    -&amp;gt; Pin&amp;lt;Box&amp;lt;dyn Future&amp;lt;Output &#x3D; String&amp;gt; + Send + &#x27;_&amp;gt;&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is significantly more verbose, but it achieves the goal of combining async with traits. What&#x27;s more, the &lt;a href&#x3D;&quot;https://crates.io/crates/async-trait&quot;&gt;async-trait&lt;/a&gt; proc macro crate rewrites your code for you, allowing you to simply write&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;#[async_trait]
trait Database {
    async fn fetch_data(&amp;amp;self) -&amp;gt; String;
}

#[async_trait]
impl Database for MyDb {
    async fn fetch_data(&amp;amp;self) -&amp;gt; String { ... }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is an excellent solution for the people who can use it!&lt;/p&gt;
&lt;p&gt;Unfortunately, not everyone can. You can&#x27;t use &lt;code&gt;Box&lt;/code&gt; in no_std contexts. Dynamic dispatch and allocation come with overhead that can be &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async/vision/submitted_stories/status_quo/barbara_benchmarks_async_trait.html&quot;&gt;overwhelming&lt;/a&gt; for highly performance-sensitive code. Finally, it bakes a lot of assumptions into the trait itself: allocation with &lt;code&gt;Box&lt;/code&gt;, dynamic dispatch, and the &lt;code&gt;Send&lt;/code&gt;-ness of the futures. This makes it unsuitable for many libraries.&lt;/p&gt;
&lt;p&gt;Besides, users &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async/vision/submitted_stories/status_quo/alan_needs_async_in_traits.html&quot;&gt;expect&lt;/a&gt; to be able to write &lt;code&gt;async fn&lt;/code&gt; in traits, and the experience of adding an external crate dependency is a papercut that gives async Rust a reputation for being difficult to use.&lt;/p&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#manual-poll-implementations&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;manual-poll-implementations&quot;&gt;&lt;/a&gt;Manual &lt;code&gt;poll&lt;/code&gt; implementations&lt;/h4&gt;
&lt;p&gt;Traits that need to work with zero overhead or in no_std contexts have another option: they can take the concept of polling from the &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/future/trait.Future.html&quot;&gt;&lt;code&gt;Future&lt;/code&gt; trait&lt;/a&gt; and build it directly into their interface. The &lt;code&gt;Future::poll&lt;/code&gt; method returns &lt;code&gt;Poll::Ready(Output)&lt;/code&gt; if the future is complete and &lt;code&gt;Poll::Pending&lt;/code&gt; if the future is waiting on some other event.&lt;/p&gt;
&lt;p&gt;You can see this pattern, for example, in the current version of the unstable &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/async_iter/trait.AsyncIterator.html&quot;&gt;AsyncIterator&lt;/a&gt; trait. The signature of &lt;code&gt;AsyncIterator::poll_next&lt;/code&gt; is a cross between &lt;code&gt;Future::poll&lt;/code&gt; and &lt;code&gt;Iterator::next&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;pub trait AsyncIterator {
    type Item;

    fn poll_next(
        self: Pin&amp;lt;&amp;amp;mut Self&amp;gt;,
        cx: &amp;amp;mut Context&amp;lt;&#x27;_&amp;gt;
    ) -&amp;gt; Poll&amp;lt;Option&amp;lt;Self::Item&amp;gt;&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Before async/await, it was very common to write manual &lt;code&gt;poll&lt;/code&gt; implementations. Unfortunately, they proved challenging to write correctly. In the &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2021/03/18/async-vision-doc.html&quot;&gt;vision document&lt;/a&gt; process we underwent last year, we received a number of reports on how this was &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async/vision/submitted_stories/status_quo/alan_hates_writing_a_stream.html&quot;&gt;extremely difficult&lt;/a&gt; and a &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async/vision/submitted_stories/status_quo/barbara_polls_a_mutex.html&quot;&gt;source of bugs&lt;/a&gt; for Rust users.&lt;/p&gt;
&lt;p&gt;In fact, the difficulty of writing manual poll implementations was a primary reason for adding async/await to the core language in the first place.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-supported-in-nightly&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-supported-in-nightly&quot;&gt;&lt;/a&gt;What&#x27;s supported in nightly&lt;/h2&gt;
&lt;p&gt;We&#x27;ve been working to support &lt;code&gt;async fn&lt;/code&gt; directly in traits, and an implementation &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/101224&quot;&gt;recently landed&lt;/a&gt; in nightly! The feature still has some rough edges, but let&#x27;s take a look at what you can do with it.&lt;/p&gt;
&lt;p&gt;First, as you might expect, you can write and implement traits just like the above.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;#![feature(async_fn_in_trait)]

trait Database {
    async fn fetch_data(&amp;amp;self) -&amp;gt; String;
}

impl Database for MyDb {
    async fn fetch_data(&amp;amp;self) -&amp;gt; String { ... }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One thing this will allow us to do is standardize new traits we&#x27;ve been waiting on this feature for. For example, the &lt;code&gt;AsyncIterator&lt;/code&gt; trait from above is significantly more complicated than its analogue, &lt;code&gt;Iterator&lt;/code&gt;. With the new support, we can simply write this instead:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;#![feature(async_fn_in_trait)]

trait AsyncIterator {
    type Item;
    async fn next(&amp;amp;mut self) -&amp;gt; Option&amp;lt;Self::Item&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There&#x27;s a decent chance that the trait in the standard library will end up exactly like this! For now, you can also use the one in the &lt;a href&#x3D;&quot;https://docs.rs/async-iterator/latest/async_iterator/&quot;&gt;&lt;code&gt;async_iterator&lt;/code&gt; crate&lt;/a&gt; and write generic code with it, just like you would normally.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;async fn print_all&amp;lt;I: AsyncIterator&amp;gt;(mut count: I)
where
    I::Item: Display,
{
    while let Some(x) &#x3D; count.next().await {
        println!(&amp;quot;{x}&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#limitation-spawning-from-generics&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;limitation-spawning-from-generics&quot;&gt;&lt;/a&gt;Limitation: Spawning from generics&lt;/h3&gt;
&lt;p&gt;There is a catch! If you try to &lt;em&gt;spawn&lt;/em&gt; from a generic function like &lt;code&gt;print_all&lt;/code&gt;, and (like the majority of async users) you use a work stealing executor that requires spawned tasks to be &lt;code&gt;Send&lt;/code&gt;, you&#x27;ll hit an error which is not easily resolved.&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn2&quot; id&#x3D;&quot;fnref2&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn spawn_print_all&amp;lt;I: AsyncIterator + Send + &#x27;static&amp;gt;(mut count: I)
where
    I::Item: Display,
{
    tokio::spawn(async move {
        //       ^^^^^^^^^^^^
        // ERROR: future cannot be sent between threads safely
        while let Some(x) &#x3D; count.next().await {
            //              ^^^^^^^^^^^^
            // note: future is not &#x60;Send&#x60; as it awaits another future which is not &#x60;Send&#x60;
            println!(&amp;quot;{x}&amp;quot;);
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can see that we added an &lt;code&gt;I: Send&lt;/code&gt; bound in the function signature, but that was not enough. To satisfy this error we need to say that the &lt;em&gt;future returned by &lt;code&gt;next()&lt;/code&gt;&lt;/em&gt; is &lt;code&gt;Send&lt;/code&gt;. But as we saw at the beginning of this post, async functions return anonymous types. There&#x27;s no way to express bounds on those types.&lt;/p&gt;
&lt;p&gt;There are potential solutions to this problem that we&#x27;ll be exploring in a follow-up post. But for now, there are a couple things you can do to get out of a situation like this.&lt;/p&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#hypothesis-this-is-uncommon&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;hypothesis-this-is-uncommon&quot;&gt;&lt;/a&gt;Hypothesis: This is uncommon&lt;/h4&gt;
&lt;p&gt;First, you &lt;em&gt;may&lt;/em&gt; be surprised to find that this situation just doesn&#x27;t occur that often in practice. For example, we can spawn a task that invokes the above &lt;code&gt;print_all&lt;/code&gt; function &lt;a href&#x3D;&quot;https://play.rust-lang.org/?version&#x3D;nightly&amp;amp;mode&#x3D;debug&amp;amp;edition&#x3D;2021&amp;amp;gist&#x3D;6ffde69ba43c6c5094b7fbdae11774a9&quot;&gt;without any problem&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;async fn do_something() {
    let iter &#x3D; Countdown::new(10);
    executor::spawn(print_all(iter));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This works without any &lt;code&gt;Send&lt;/code&gt; bounds whatsoever! This works because &lt;code&gt;do_something&lt;/code&gt; knows the concrete type of our iterator, &lt;code&gt;Countdown&lt;/code&gt;. The compiler knows that this type is &lt;code&gt;Send&lt;/code&gt;, and that &lt;code&gt;print_all(iter)&lt;/code&gt; therefore produces a future that is &lt;code&gt;Send&lt;/code&gt;.&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn3&quot; id&#x3D;&quot;fnref3&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;One hypothesis is that while people will hit this problem, they will encounter it relatively infrequently, because most of the time &lt;code&gt;spawn&lt;/code&gt; won&#x27;t be called in code that&#x27;s generic over a trait with async functions.&lt;/p&gt;
&lt;p&gt;We would like to start gathering data on people&#x27;s actual experiences with this. If you have relevant experience to share, &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/103854&quot;&gt;please comment on this issue&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#when-it-does-happen&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;when-it-does-happen&quot;&gt;&lt;/a&gt;When it does happen&lt;/h4&gt;
&lt;p&gt;Eventually you probably &lt;em&gt;will&lt;/em&gt; want to spawn from a context that&#x27;s generic over an async trait that you call. What then!?&lt;/p&gt;
&lt;p&gt;For now it&#x27;s possible to use another new nightly-only feature, &lt;code&gt;return_position_impl_trait_in_trait&lt;/code&gt;, to express the bound you need directly in your trait:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;#![feature(return_position_impl_trait_in_trait)]

trait SpawnAsyncIterator: Send + &#x27;static {
    type Item;
    fn next(&amp;amp;mut self) -&amp;gt; impl Future&amp;lt;Output &#x3D; Option&amp;lt;Self::Item&amp;gt;&amp;gt; + Send + &#x27;_;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we&#x27;ve &lt;em&gt;desugared&lt;/em&gt; our &lt;code&gt;async fn&lt;/code&gt; to a regular function returning &lt;code&gt;impl Future + &#x27;_&lt;/code&gt;, which works just like normal &lt;code&gt;async fn&lt;/code&gt;s do. It&#x27;s more verbose, but it gives us a place to put a &lt;code&gt;+ Send&lt;/code&gt; bound! What&#x27;s more, you can continue to use &lt;code&gt;async fn&lt;/code&gt; in an &lt;code&gt;impl&lt;/code&gt; of this trait.&lt;/p&gt;
&lt;p&gt;The downside of this approach is that the trait becomes less generic, making it less suitable for library code. If you want to maintain two separate versions of a trait, you can do that, and (perhaps) provide macros to make it easier to implement both.&lt;/p&gt;
&lt;p&gt;This solution is intended to be temporary. We&#x27;d like to implement a better solution in the language itself, but since this is a nightly-only feature we prefer to get more people trying it out as soon as possible.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#limitation-dynamic-dispatch&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;limitation-dynamic-dispatch&quot;&gt;&lt;/a&gt;Limitation: Dynamic dispatch&lt;/h3&gt;
&lt;p&gt;There&#x27;s one final limitation: You can&#x27;t call an &lt;code&gt;async fn&lt;/code&gt; with a &lt;code&gt;dyn Trait&lt;/code&gt;. Designs to support this exist&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn4&quot; id&#x3D;&quot;fnref4&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;, but are in the earlier stages. If you need dynamic dispatch from a trait, you&#x27;re better off using the &lt;code&gt;async_trait&lt;/code&gt; macro for now.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#path-to-stabilization&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;path-to-stabilization&quot;&gt;&lt;/a&gt;Path to stabilization&lt;/h2&gt;
&lt;p&gt;The async working group would like to get something useful in the hands of Rust users, even if it doesn&#x27;t do &lt;em&gt;everything&lt;/em&gt; they might want. That&#x27;s why despite having some limitations, the current version of &lt;code&gt;async fn&lt;/code&gt; in traits might not be far off from stabilization.&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn5&quot; id&#x3D;&quot;fnref5&quot;&gt;5&lt;/a&gt;&lt;/sup&gt; You can follow progress by watching the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/91611&quot;&gt;tracking issue&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;There are two big questions to answer first:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Do we need to solve the &amp;quot;spawning from generics&amp;quot; (&lt;code&gt;Send&lt;/code&gt; bound) problem first?&lt;/strong&gt; Please leave feedback on &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/103854&quot;&gt;this issue&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;What other bugs and quality issues exist?&lt;/strong&gt; Please file &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/new/choose&quot;&gt;new issues&lt;/a&gt; for these. You can view &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/labels/F-async_fn_in_trait&quot;&gt;known issues here&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you&#x27;re an async Rust enthusiast and are willing to try experimental new features, we&#x27;d very much appreciate it if you gave it a spin!&lt;/p&gt;
&lt;p&gt;If you use &lt;code&gt;#[async_trait]&lt;/code&gt;, you can try removing it from some traits (and their impls) where you don&#x27;t use dynamic dispatch. Or if you&#x27;re writing new async code, try using it there. Either way, you can tell us about your experience at the links above.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#conclusion&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;conclusion&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;This work was made possible thanks to the efforts of many people, including&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Michael Goulet&lt;/li&gt;
&lt;li&gt;Santiago Pastorino&lt;/li&gt;
&lt;li&gt;Oli Scherer&lt;/li&gt;
&lt;li&gt;Eric Holk&lt;/li&gt;
&lt;li&gt;Dan Johnson&lt;/li&gt;
&lt;li&gt;Bryan Garza&lt;/li&gt;
&lt;li&gt;Niko Matsakis&lt;/li&gt;
&lt;li&gt;Tyler Mandry&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In addition it was built on top of years of compiler work that enabled us to ship &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2022/10/28/gats-stabilization.html&quot;&gt;GATs&lt;/a&gt; as well as other fundamental type system improvements. We&#x27;re deeply grateful to all those who contributed; this work would not be possible without you. Thank you!&lt;/p&gt;
&lt;p&gt;To learn more about this feature and the challenges behind it, check out the &lt;a href&#x3D;&quot;https://rust-lang.github.io/rfcs/3185-static-async-fn-in-trait.html&quot;&gt;Static async fn in traits RFC&lt;/a&gt; and &lt;a href&#x3D;&quot;https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/&quot;&gt;why async fn in traits are hard&lt;/a&gt;. Also stay tuned for a follow-up post where we explore language extensions that make it possible to express &lt;code&gt;Send&lt;/code&gt; bounds without a special trait.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Thanks to Yoshua Wuyts, Nick Cameron, Dan Johnson, Santiago Pastorino, Eric Holk, and Niko Matsakis for reviewing a draft of this post.&lt;/em&gt;&lt;/p&gt;
&lt;section class&#x3D;&quot;footnotes&quot;&gt;
&lt;ol&gt;
&lt;li id&#x3D;&quot;fn1&quot;&gt;
&lt;p&gt;This feature is called &lt;a href&#x3D;&quot;https://rust-lang.github.io/rfcs/2515-type_alias_impl_trait.html&quot;&gt;&amp;quot;type alias impl trait&amp;quot;&lt;/a&gt;. &lt;a href&#x3D;&quot;#fnref1&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id&#x3D;&quot;fn2&quot;&gt;
&lt;p&gt;The actual error message produced by the compiler is a bit noisier than this, but that will be improved. &lt;a href&#x3D;&quot;#fnref2&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id&#x3D;&quot;fn3&quot;&gt;
&lt;p&gt;Auto traits such as &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; are special in this way. The compiler knows that the return type of &lt;code&gt;print_all&lt;/code&gt; is &lt;code&gt;Send&lt;/code&gt; if and only if the type of its argument &lt;code&gt;Send&lt;/code&gt;, and unlike with regular traits, it is allowed to use this knowledge when type checking your program. &lt;a href&#x3D;&quot;#fnref3&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id&#x3D;&quot;fn4&quot;&gt;
&lt;p&gt;See &lt;a href&#x3D;&quot;https://rust-lang.github.io/async-fundamentals-initiative/explainer/async_fn_in_dyn_trait.html&quot;&gt;Async fn in dyn trait&lt;/a&gt; on the initiative website, as well as posts 8 and 9 in &lt;a href&#x3D;&quot;https://smallcultfollowing.com/babysteps/blog/2022/09/21/dyn-async-traits-part-9-callee-site-selection/&quot;&gt;this series&lt;/a&gt;. &lt;a href&#x3D;&quot;#fnref4&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id&#x3D;&quot;fn5&quot;&gt;
&lt;p&gt;When? Possibly sometime in the next six months or so. But don&#x27;t hold me to it :) &lt;a href&#x3D;&quot;#fnref5&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>

        <author>
            <name>Tyler Mandry</name>
        </author>
    </entry>
    
    <entry>
        <title>1.65.0 pre-release testing</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2022/10/31/1.65.0-prerelease.html" type="text/html" title="1.65.0 pre-release testing" />
        <published>2022-10-31T00:00:00+00:00</published>
        <updated>2022-10-31T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2022/10/31/1.65.0-prerelease.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2022/10/31/1.65.0-prerelease.html">&lt;p&gt;The 1.65.0 pre-release is ready for testing. The release is scheduled for
November 03. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1650-2022-11-03&quot;&gt;Release notes can be found here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can try it out locally by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-plain&quot;&gt;RUSTUP_DIST_SERVER&#x3D;https://dev-static.rust-lang.org rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The index is &lt;a href&#x3D;&quot;https://dev-static.rust-lang.org/dist/2022-10-31/index.html&quot;&gt;https://dev-static.rust-lang.org/dist/2022-10-31/index.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can leave feedback on the &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/rust-1-65-0-pre-release-testing/17660&quot;&gt;internals thread&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The release team is also thinking about changes to our pre-release process:
we&#x27;d love your feedback &lt;a href&#x3D;&quot;https://github.com/rust-lang/release-team/issues/16&quot;&gt;on this GitHub issue&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Release automation</name>
        </author>
    </entry>
    
    <entry>
        <title>Governance Update</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2022/10/06/governance-update.html" type="text/html" title="Governance Update" />
        <published>2022-10-06T00:00:00+00:00</published>
        <updated>2022-10-06T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2022/10/06/governance-update.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2022/10/06/governance-update.html">&lt;p&gt;As part of ongoing work on governance, Rust leadership jointly established a group, &amp;quot;leadership chat&amp;quot;, consisting of the Core team, leads of all teams on the &lt;a href&#x3D;&quot;https://www.rust-lang.org/governance&quot;&gt;governance page&lt;/a&gt;, the Moderation team, and the project directors on the Rust Foundation board. This group has been serving as an interim governing body while efforts to establish the next evolution of Rust project-wide governance are underway.&lt;/p&gt;
&lt;p&gt;We previously posted &lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2022/05/19/governance-update.html&quot;&gt;an update on the future of Rust project-wide governance&lt;/a&gt;. In that post, we promised that the next steps would be to &amp;quot;take the findings we have so far and begin crafting proposals for how the Rust project will be governed in the future.&amp;quot; In this post, we&#x27;d like to provide an update on the status of this work.&lt;/p&gt;
&lt;p&gt;Late in July, the interim leadership team established an informal working group to conduct further research and draft an RFC for the establishment of a new project-wide governing body. This RFC relies on the requirements document&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn1&quot; id&#x3D;&quot;fnref1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; that was compiled as a result of in-depth interviews conducted by Ryan Levick and Mara Bos with team members from across the Rust project. Currently, there are seven people involved in this working group: Ryan Levick (Core Project Director), JT (Core), Mark Rousskov (Core Project Director, Release Lead), Jane Losare-Lusby (Collaboration Project Director), Josh Triplett (Lang Team Lead), Josh Gould (Moderation), and Khionu Sybiern (Moderation).&lt;/p&gt;
&lt;p&gt;The working group&#x27;s objective is not to completely re-engineer every aspect of Rust&#x27;s governance model — that would require the participation and consent of all the other teams working in the project — but rather to lay the foundation for dynamic project-wide governance by introducing policies and procedures for constraining, monitoring, and adjusting the governance model in response to the project&#x27;s evolving needs. As part of this work, not only is explicit attention being paid to the issues that led to the resignation of the &lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2021/11/25/in-response-to-the-moderation-team-resignation.html&quot;&gt;former mod team&lt;/a&gt; last November but also additional governance shortfalls identified through Ryan&#x27;s and Mara&#x27;s research. At the same time, we&#x27;re deliberately keeping the scope small in the hope of getting out of the way as soon as possible to let the work continue under the new more representative and accountable governance body.&lt;/p&gt;
&lt;p&gt;According to our current projections, we are roughly halfway through drafting this RFC since the process began at the end of August. We&#x27;re still making steady progress, and when we have a full draft, we&#x27;ll post it for project-wide review. In the interest of transparency, we will continue to publish updates until the RFC is made available. The goal of keeping the initial discussions private is not to exclude people, but rather to keep the size of the group discussions manageable&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn2&quot; id&#x3D;&quot;fnref2&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; during the early stages of the RFC drafting process. We are completely open to sharing early drafts and discussing current plans outside of our weekly meetings. Any project participants with questions or concerns are encouraged to get in touch with the working group&#x27;s members.&lt;/p&gt;
&lt;section class&#x3D;&quot;footnotes&quot;&gt;
&lt;ol&gt;
&lt;li id&#x3D;&quot;fn1&quot;&gt;
&lt;p&gt;Which can be found in the &lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2022/05/19/governance-update.html&quot;&gt;previous governance update post&lt;/a&gt; &lt;a href&#x3D;&quot;#fnref1&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id&#x3D;&quot;fn2&quot;&gt;
&lt;p&gt;Even with &amp;quot;only&amp;quot; seven people, having discussions of this magnitude is difficult. &lt;a href&#x3D;&quot;#fnref2&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>

        <author>
            <name>Ryan Levick</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing the Rust Style Team</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2022/09/29/announcing-the-rust-style-team.html" type="text/html" title="Announcing the Rust Style Team" />
        <published>2022-09-29T00:00:00+00:00</published>
        <updated>2022-09-29T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2022/09/29/announcing-the-rust-style-team.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2022/09/29/announcing-the-rust-style-team.html">&lt;p&gt;Rust has a standardized style, and an implementation of that style in the
&lt;code&gt;rustfmt&lt;/code&gt; tool. The standardized style helps Rust developers feel comfortable
and at home in many different projects, and the tooling support from &lt;code&gt;rustfmt&lt;/code&gt;
makes it easy to maintain and to incorporate in continuous integration.
&lt;code&gt;rustfmt&lt;/code&gt; also provides many options to customize the style, but the style
guide defines the defaults, and most projects use those defaults.&lt;/p&gt;
&lt;p&gt;The standard Rust style resulted from development and discussion within the
Rust style team, between 2016 and 2018. After publishing the style guide, the
Rust style team concluded its active work, by design.&lt;/p&gt;
&lt;p&gt;However, as the Rust language develops, we have a regular need for improvements
to the style guide, such as to support new language constructs. This includes
minor language changes, as well as highly anticipated new features such as
&lt;code&gt;let&lt;/code&gt;-chaining (RFC 2497) and &lt;code&gt;let&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt; (RFC 3137). New constructs like
these, by default, get ignored and not formatted by rustfmt, and subsequently
need formatting added. Some of this work has fallen to the rustfmt team in
recent years, but the rustfmt team would prefer to implement style
determinations made by another team rather than making such determinations
itself.&lt;/p&gt;
&lt;p&gt;In addition, rustfmt maintains backwards compatibility guarantees: code that
has been correctly formatted with rustfmt won&#x27;t get formatted differently with
a future version of rustfmt. This avoids churn, and avoids creating CI failures
when people use rustfmt to check style in CI. However, this also prevents
evolving the Rust style to take community desires into account and improve
formatting over time. rustfmt provides various configuration options to change
its default formatting, and many of those options represent changes that many
people in the community would like enabled by default.&lt;/p&gt;
&lt;p&gt;For instance, many people prefer to format their &lt;code&gt;use&lt;/code&gt; lines in three blocks:
imports from the standard library, imports from external crates, and then
imports from modules within the same project. &lt;code&gt;rustfmt&lt;/code&gt; supports this via the
option &lt;code&gt;group_imports &#x3D; StdExternalCrate&lt;/code&gt;, but cannot make this the default
without causing CI failures in existing projects. We need a way to evolve the
default Rust style compatibly, similar in spirit to the mechanisms we use for
Rust editions: allowing existing style to continue working, and allowing people
to opt into new style.&lt;/p&gt;
&lt;p&gt;To solve both of these problems, &lt;a href&#x3D;&quot;https://rust-lang.github.io/rfcs/3309-style-team.html&quot;&gt;RFC
3309&lt;/a&gt; has revived the
Rust style team, with three goals:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Making determinations about styling for new Rust constructs&lt;/li&gt;
&lt;li&gt;Evolving the existing Rust style&lt;/li&gt;
&lt;li&gt;Defining mechanisms to evolve the Rust style while taking backwards
compatibility into account&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We don&#x27;t plan to make any earth-shattering style changes; the look and feel of
Rust will remain largely the same. Evolutions to the default Rust style will
largely consist of established &lt;code&gt;rustfmt&lt;/code&gt; options people already widely enable,
or would enable if they were stable.&lt;/p&gt;
&lt;p&gt;We expect that the initial work of the style team will focus on clearing a
backlog of new language constructs that lack formatting guidance. Afterwards,
we will look towards defining and implementing the mechanisms to evolve the
default Rust style, and then begin introducing style improvements.&lt;/p&gt;
</content>

        <author>
            <name>Josh Triplett</name>
        </author>
    </entry>
    
    <entry>
        <title>Rust Compiler Early October 2022 Steering Cycle</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2022/09/23/compiler-team-sep-oct-steering-cycle.html" type="text/html" title="Rust Compiler Early October 2022 Steering Cycle" />
        <published>2022-09-23T00:00:00+00:00</published>
        <updated>2022-09-23T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2022/09/23/compiler-team-sep-oct-steering-cycle.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2022/09/23/compiler-team-sep-oct-steering-cycle.html">&lt;p&gt;On &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/238009-t-compiler.2Fmeetings/topic/.5Bplanning.20meeting.5D.202022-09-23/near/300372578&quot;&gt;Friday, September 23rd&lt;/a&gt;, the Rust Compiler team had a planning meeting for the September/October 2022 steering cycle.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#t-compiler-june-steering-schedule&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;t-compiler-june-steering-schedule&quot;&gt;&lt;/a&gt;T-compiler June Steering Schedule&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Meeting Id&lt;/th&gt;
&lt;th&gt;Meeting Topic&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href&#x3D;&quot;https://calendar.google.com/event?action&#x3D;TEMPLATE&amp;amp;tmeid&#x3D;Mm9tM2VzOWszaWw0Z3RudWlhNzF0ZHMwbzMgNnU1cnJ0Y2U2bHJ0djA3cGZpM2RhbWdqdXNAZw&amp;amp;tmsrc&#x3D;6u5rrtce6lrtv07pfi3damgjus%40group.calendar.google.com&quot;&gt;2022-09-30&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/559&quot;&gt;compiler-team#559&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;2022 Q3 P-high review&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href&#x3D;&quot;https://calendar.google.com/event?action&#x3D;TEMPLATE&amp;amp;tmeid&#x3D;NnA2bWtoaGQ5NnVudGkwdnM5aWZ1YmpqNG0gNnU1cnJ0Y2U2bHJ0djA3cGZpM2RhbWdqdXNAZw&amp;amp;tmsrc&#x3D;6u5rrtce6lrtv07pfi3damgjus%40group.calendar.google.com&quot;&gt;2022-10-07&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/544&quot;&gt;compiler-team#544&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Survey retrospective&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href&#x3D;&quot;https://calendar.google.com/event?action&#x3D;TEMPLATE&amp;amp;tmeid&#x3D;NW52ZGNhYzVrbWJxdG0yOTBpN2Q2ZmExaXIgNnU1cnJ0Y2U2bHJ0djA3cGZpM2RhbWdqdXNAZw&amp;amp;tmsrc&#x3D;6u5rrtce6lrtv07pfi3damgjus%40group.calendar.google.com&quot;&gt;2022-10-14&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/540&quot;&gt;compiler-team#540&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Dealing with disabled tests&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href&#x3D;&quot;https://calendar.google.com/event?action&#x3D;TEMPLATE&amp;amp;tmeid&#x3D;MDJyYnJ1cGFtdWR1c2lnNjFmcHJ2b3JlODFfMjAyMjEwMjFUMTQwMDAwWiA2dTVycnRjZTZscnR2MDdwZmkzZGFtZ2p1c0Bn&amp;amp;tmsrc&#x3D;6u5rrtce6lrtv07pfi3damgjus%40group.calendar.google.com&amp;amp;scp&#x3D;ALL&quot;&gt;2022-10-21&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;none&lt;/td&gt;
&lt;td&gt;(planning for October/November cycle)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#details&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;details&quot;&gt;&lt;/a&gt;Details&lt;/h3&gt;
&lt;p&gt;Every fourth Friday, the Rust compiler team decides how
it is going to use its scheduled steering and design meeting time over the next
three Fridays.&lt;/p&gt;
&lt;p&gt;On Friday, 30 September, we will do a quarterly &lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/559&quot;&gt;review of the open P-high issues&lt;/a&gt;.
pnkfelix will do some ahead of time work &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/reviewing.20P-high.20issues.202022.20.28Q3.29/near/300390068&quot;&gt;in zulip&lt;/a&gt;
triaging
some of the issues, and potentially prepare a meeting document summarizing the
remainder, to maximize the quality of our synchronous in-meeting time.&lt;/p&gt;
&lt;p&gt;On Friday, 7 October, we will do a &lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/544&quot;&gt;retrospective&lt;/a&gt; on the 2022 T-compiler surveys
that were used to drive the February ambitions post and the midyear update post.
We will talk about the questions that were asked, what we wish had been asked,
what value we got from the survey as it went, and what to do the same and/or
differently in the future. (In principle, this meeting should inform the way
that we drive the retrospective on how the year as a whole went for the compiler
team.)&lt;/p&gt;
&lt;p&gt;On Friday, 14 October, we will discuss how to &lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/540&quot;&gt;deal with &amp;quot;disabled tests&amp;quot;&lt;/a&gt;:
tests that are turned off at some point (e.g. due to failures in a component we
do not control). We do not currently have any protocols in place to review such
tests or decide when to try to re-enabling them.&lt;/p&gt;
&lt;p&gt;On Friday, 21 October, we will hold our planning meeting for the next steering
cycle in October and November.&lt;/p&gt;
&lt;p&gt;Each meeting will run from 2pm to 3pm GMT, and will take place on the
&lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/238009-t-compiler.2Fmeetings&quot;&gt;T-compiler/meetings zulip stream&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Felix Klock</name>
        </author>
    </entry>
    
    <entry>
        <title>1.64.0 pre-release testing</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2022/09/19/1.64.0-prerelease.html" type="text/html" title="1.64.0 pre-release testing" />
        <published>2022-09-19T00:00:00+00:00</published>
        <updated>2022-09-19T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2022/09/19/1.64.0-prerelease.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2022/09/19/1.64.0-prerelease.html">&lt;p&gt;The 1.64.0 pre-release is ready for testing. The release is scheduled for
September 22. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1640-2022-09-22&quot;&gt;Release notes can be found here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can try it out locally by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-plain&quot;&gt;RUSTUP_DIST_SERVER&#x3D;https://dev-static.rust-lang.org rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The index is &lt;a href&#x3D;&quot;https://dev-static.rust-lang.org/dist/2022-09-19/index.html&quot;&gt;https://dev-static.rust-lang.org/dist/2022-09-19/index.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can leave feedback on the &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/rust-1-64-0-pre-release-testing/17409&quot;&gt;internals thread&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The release team is also thinking about changes to our pre-release process:
we&#x27;d love your feedback &lt;a href&#x3D;&quot;https://github.com/rust-lang/release-team/issues/16&quot;&gt;on this GitHub issue&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Release automation</name>
        </author>
    </entry>
    
    <entry>
        <title>Contribute to the diagnostic translation effort!</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2022/08/16/diagnostic-effort.html" type="text/html" title="Contribute to the diagnostic translation effort!" />
        <published>2022-08-16T00:00:00+00:00</published>
        <updated>2022-08-16T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2022/08/16/diagnostic-effort.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2022/08/16/diagnostic-effort.html">&lt;p&gt;The Rust Diagnostics working group is leading an effort to add support for
internationalization of error messages in the compiler, allowing the compiler
to produce output in languages other than English.&lt;/p&gt;
&lt;p&gt;For example, consider the following diagnostic where a user has used a colon to
specify a function&#x27;s return type instead of an arrow:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-text&quot;&gt;error: return types are denoted using &#x60;-&amp;gt;&#x60;
 --&amp;gt; src/main.rs:1:21
  |
1 | fn meaning_of_life(): u32 { 42 }
  |                     ^ help: use &#x60;-&amp;gt;&#x60; instead
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We could output that diagnostic in Chinese:&lt;/p&gt;
&lt;pre lang&#x3D;&quot;zh-CN&quot;&gt;
&lt;code class&#x3D;&quot;language-text&quot;&gt;错误: 返回类型使用&#x60;-&gt;&#x60;表示
 --&gt; src/main.rs:1:21
  |
1 | fn meaning_of_life(): u32 { 42 }
  |                     ^ 帮助: 使用&#x60;-&gt;&#x60;来代替
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or even in Spanish:&lt;/p&gt;
&lt;pre lang&#x3D;&quot;es&quot;&gt;
&lt;code class&#x3D;&quot;language-text&quot;&gt;error: el tipo de retorno se debe indicar mediante &#x60;-&gt;&#x60;
 --&gt; src/main.rs:1:21
  |
1 | fn meaning_of_life(): u32 { 42 }
  |                     ^ ayuda: utilice &#x60;-&gt;&#x60; en su lugar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Translated error messages will allow non-native speakers of English to use Rust
in their preferred language.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-the-current-status&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-the-current-status&quot;&gt;&lt;/a&gt;What&#x27;s the current status?&lt;/h2&gt;
&lt;p&gt;Implementation on diagnostic translation has started, but we&#x27;re looking for
help!&lt;/p&gt;
&lt;p&gt;The core infrastructure for diagnostic translation has been implemented in
&lt;code&gt;rustc&lt;/code&gt;; this makes it possible for Rust to emit a diagnostic with translated
messages. However, every diagnostic in &lt;code&gt;rustc&lt;/code&gt; has to be ported to use this new
infrastructure, otherwise they can&#x27;t be translated. That&#x27;s a lot of work, so
the diagnostics working group has chosen to combine the translation effort with
a transition to &amp;quot;diagnostic structs&amp;quot; (more on that later) and get both done at
once.&lt;/p&gt;
&lt;p&gt;Once most diagnostic messages have been ported to the new infrastructure, then
the diagnostics working group will start creating a workflow for translation
teams to translate all of the diagnostic messages to different languages.&lt;/p&gt;
&lt;p&gt;Every pull request related to diagnostic translation is tagged with
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues?q&#x3D;is%3Aopen+label%3AA-translation+sort%3Aupdated-desc&quot;&gt;&lt;code&gt;A-translation&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#getting-involved&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;getting-involved&quot;&gt;&lt;/a&gt;Getting involved&lt;/h2&gt;
&lt;p&gt;There&#x27;s a lot of work to do on diagnostic translation, but the good news is that
lots of the work can be done in parallel, and it doesn&#x27;t require background in
compiler development or familiarity with &lt;code&gt;rustc&lt;/code&gt; to contribute!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;If you are interested in getting involved, take a look at &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/100717&quot;&gt;#100717&lt;/a&gt; to find
out where to get started!&lt;/strong&gt; You can ask for help in
&lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/147480-t-compiler.2Fwg-diagnostics&quot;&gt;&lt;code&gt;#t-compiler/wg-diagnostics&lt;/code&gt;&lt;/a&gt; or reach out to &lt;a href&#x3D;&quot;https://github.com/davidtwco&quot;&gt;&lt;code&gt;@davidtwco&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This post isn&#x27;t going to be updated as the working group iterates on
and improves the workflow for diagnostic translation, so always consult the
developer guide for the most recent documentation on &lt;a href&#x3D;&quot;https://rustc-dev-guide.rust-lang.org/diagnostics/diagnostic-structs.html&quot;&gt;diagnostic
structs&lt;/a&gt; or &lt;a href&#x3D;&quot;https://rustc-dev-guide.rust-lang.org/diagnostics/translation.html&quot;&gt;diagnostic translation&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#1-setting-up-a-local-development-environment&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;1-setting-up-a-local-development-environment&quot;&gt;&lt;/a&gt;1. Setting up a local development environment&lt;/h3&gt;
&lt;p&gt;Before helping with the diagnostic translation effort, you&#x27;ll need to get your
development environment set up, so &lt;a href&#x3D;&quot;https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html&quot;&gt;follow the instructions on the &lt;code&gt;rustc&lt;/code&gt; dev
guide&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#2-getting-ready-to-port-your-first-diagnostic&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;2-getting-ready-to-port-your-first-diagnostic&quot;&gt;&lt;/a&gt;2. Getting ready to port your first diagnostic&lt;/h3&gt;
&lt;p&gt;Almost all diagnostics in &lt;code&gt;rustc&lt;/code&gt; are implemented using the traditional
&lt;code&gt;DiagnosticBuilder&lt;/code&gt; APIs, which look something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;self.struct_span_err(self.prev_token.span, &amp;quot;return types are denoted using &#x60;-&amp;gt;&#x60;&amp;quot;)
    .span_suggestion_short(
        self.prev_token.span,
        &amp;quot;use &#x60;-&amp;gt;&#x60; instead&amp;quot;,
        &amp;quot;-&amp;gt;&amp;quot;.to_string(),
        Applicability::MachineApplicable,
    )
    .emit();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;struct_span_err&lt;/code&gt; creates a new diagnostic given two things - a &lt;code&gt;Span&lt;/code&gt; and a
message. &lt;code&gt;struct_span_err&lt;/code&gt; isn&#x27;t the only diagnostic function that you&#x27;ll
encounter in the compiler&#x27;s source, but the others are all pretty similar. You
can read more about &lt;code&gt;rustc&lt;/code&gt;&#x27;s diagnostic infrastructure &lt;a href&#x3D;&quot;https://rustc-dev-guide.rust-lang.org/diagnostics.html#error-messages&quot;&gt;in the &lt;code&gt;rustc&lt;/code&gt; dev
guide&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Span&lt;/code&gt;s just identify some location in the user&#x27;s source code and you can find
them used throughout the compiler for diagnostic reporting (for example, the
location &lt;code&gt;main.rs:1:21&lt;/code&gt; from the earlier example would have been
&lt;code&gt;self.prev_token.span&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;In this example, the message is just a string literal (a &lt;code&gt;&amp;amp;&#x27;static str&lt;/code&gt;) which
needs to be replaced by an identifier for the same message in whichever
language was requested.&lt;/p&gt;
&lt;p&gt;There are two ways that a diagnostic will be ported to the new infrastructure:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;If it&#x27;s a simple diagnostic, without any logic to decide whether or not to
add suggestions or notes or helps or labels, like in the example above,
then...
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;#using-a-diagnostic-derive&quot;&gt;...use a diagnostic derive&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Otherwise...
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;#manually-implementing-sessiondiagnostic&quot;&gt;...manually implement &lt;code&gt;SessionDiagnostic&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In both cases, diagnostics are represented as types. Representing diagnostics
using types is a goal of the diagnostic working group as it helps separate
diagnostic logic from the main code paths.&lt;/p&gt;
&lt;p&gt;Every diagnostic type should implement &lt;code&gt;SessionDiagnostic&lt;/code&gt; (either manually or
automatically). In the &lt;code&gt;SessionDiagnostic&lt;/code&gt; trait, there&#x27;s a member function
which converts the trait into a &lt;code&gt;Diagnostic&lt;/code&gt; to be emitted.&lt;/p&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#using-a-diagnostic-derive&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;using-a-diagnostic-derive&quot;&gt;&lt;/a&gt;Using a diagnostic derive...&lt;/h4&gt;
&lt;p&gt;Diagnostic derives (either &lt;code&gt;SessionDiagnostic&lt;/code&gt; for whole diagnostics,
&lt;code&gt;SessionSubdiagnostic&lt;/code&gt; for parts of diagnostics, or &lt;code&gt;DecorateLint&lt;/code&gt; for lints)
can be used to automatically implement a diagnostic trait.&lt;/p&gt;
&lt;p&gt;To start, create a new type in the &lt;code&gt;errors&lt;/code&gt; module of the current crate (e.g.
&lt;code&gt;rustc_typeck::errors&lt;/code&gt; or &lt;code&gt;rustc_borrowck::errors&lt;/code&gt;) named after your
diagnostic. In our example, that might look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;struct ReturnTypeArrow {

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, we&#x27;ll need to add fields with all the information we need - that&#x27;s just a
&lt;code&gt;Span&lt;/code&gt; for us:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;struct ReturnTypeArrow {
    span: Span,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In most cases, this will just be the &lt;code&gt;Span&lt;/code&gt;s that are used by the original
diagnostic emission logic and values that are interpolated into diagnostic
messages.&lt;/p&gt;
&lt;p&gt;After that, we should add the derive, add our error attribute and annotate the
primary &lt;code&gt;Span&lt;/code&gt; (that was given to &lt;code&gt;struct_span_err&lt;/code&gt;).&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;#[derive(SessionDiagnostic)]
#[error(parser_return_type_arrow)]
struct ReturnTypeArrow {
    #[primary_span]
    span: Span,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each diagnostic should have a unique slug. By convention, these always start
with the crate that the error is related to (&lt;code&gt;parser&lt;/code&gt; in this example). This
slug will be used to find the actual diagnostic message in our translation
resources, which we&#x27;ll see shortly.&lt;/p&gt;
&lt;p&gt;Finally, we need to add any labels, notes, helps or suggestions:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;#[derive(SessionDiagnostic)]
#[error(parser_return_type_arrow)]
struct ReturnTypeArrow {
    #[primary_span]
    #[suggestion(applicability &#x3D; &amp;quot;machine-applicable&amp;quot;, code &#x3D; &amp;quot;-&amp;gt;&amp;quot;)]
    span: Span,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, there&#x27;s just a single suggestion - to replace the &lt;code&gt;:&lt;/code&gt; with
a &lt;code&gt;-&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Before we&#x27;re finished, we have to &lt;a href&#x3D;&quot;#adding-translation-resources&quot;&gt;add the diagnostic messages to the
translation resources..&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;For more documentation on diagnostic derives, see the &lt;a href&#x3D;&quot;https://rustc-dev-guide.rust-lang.org/diagnostics/diagnostic-structs.html&quot;&gt;diagnostic structs
chapter of the &lt;code&gt;rustc&lt;/code&gt; dev guide&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#manually-implementing-sessiondiagnostic&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;manually-implementing-sessiondiagnostic&quot;&gt;&lt;/a&gt;Manually implementing &lt;code&gt;SessionDiagnostic&lt;/code&gt;...&lt;/h4&gt;
&lt;p&gt;Some diagnostics are too complicated to be generated from a diagnostic type
using the diagnostic derive. In these cases, &lt;code&gt;SessionDiagnostic&lt;/code&gt; can be
implemented manually.&lt;/p&gt;
&lt;p&gt;Using the same type as in &lt;a href&#x3D;&quot;#using-a-diagnostic-derive&quot;&gt;&amp;quot;Using a diagnostic
derive...&amp;quot;&lt;/a&gt;, we can implement &lt;code&gt;SessionDiagnostic&lt;/code&gt;
as below:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;use rustc_errors::{fluent, SessionDiagnostic};

struct ReturnTypeArrow { span: Span }

impl SessionDiagnostic for ReturnTypeArrow {
    fn into_diagnostic(self, sess: &amp;amp;&#x27;_ rustc_session::Session) -&amp;gt; DiagnosticBuilder&amp;lt;&#x27;_&amp;gt; {
        sess.struct_span_err(
            self.span,
            fluent::parser_return_type_arrow,
        )
        .span_suggestion_short(
            self.span,
            fluent::suggestion,
            &amp;quot;-&amp;gt;&amp;quot;.to_string(),
            Applicability::MachineApplicable,
        )
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Instead of using strings for the messages as in the original diagnostic
emission logic, typed identifiers referring to translation resources are used.
Now we just have to &lt;a href&#x3D;&quot;#adding-translation-resources&quot;&gt;add the diagnostic messages to the translation
resources..&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#examples&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;examples&quot;&gt;&lt;/a&gt;Examples&lt;/h4&gt;
&lt;p&gt;For more examples of diagnostics ported to use the diagnostic derive or written
manually, see the following pull requests:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/98353&quot;&gt;#98353&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/98415&quot;&gt;#98415&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/97093&quot;&gt;#97093&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/99213&quot;&gt;#99213&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For more examples, see the pull requests labelled &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues?q&#x3D;is%3Aopen+label%3AA-translation+sort%3Aupdated-desc&quot;&gt;&lt;code&gt;A-translation&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#adding-translation-resources&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;adding-translation-resources&quot;&gt;&lt;/a&gt;Adding translation resources...&lt;/h4&gt;
&lt;p&gt;Every slug in a diagnostic derive or typed identifier in a manual
implementation needs to correspond to a message in a translation resource.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rustc&lt;/code&gt;&#x27;s translations use &lt;a href&#x3D;&quot;http://projectfluent.org/&quot;&gt;Fluent&lt;/a&gt;, an asymmetric translation system.
For each crate in the compiler which emits diagnostics, there is a
corresponding Fluent resource at
&lt;code&gt;compiler/rustc_error_messages/locales/en-US/$crate.ftl&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Error messages need to be added to this resource (a macro will then generate
the typed identifier corresponding to the message).&lt;/p&gt;
&lt;p&gt;For our example, we should add the following Fluent to
&lt;code&gt;compiler/rustc_error_messages/locales/en-US/parser.ftl&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-fluent&quot;&gt;parser_return_type_arrow &#x3D; return types are denoted using &#x60;-&amp;gt;&#x60;
    .suggestion &#x3D; use &#x60;-&amp;gt;&#x60; instead
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;parser_return_type_arrow&lt;/code&gt; will generate a &lt;code&gt;parser::return_type_arrow&lt;/code&gt; type (in
&lt;code&gt;rustc_errors::fluent&lt;/code&gt;) that can be used with diagnostic structs and the
diagnostic builder.&lt;/p&gt;
&lt;p&gt;Subdiagnostics are &amp;quot;attributes&amp;quot; of the primary Fluent message - by convention,
the name of attributes are the type of subdiagnostic, such as &amp;quot;suggestion&amp;quot;, but
this can be changed when there are multiple of one kind of subdiagnostic.&lt;/p&gt;
&lt;p&gt;Now that the Fluent resource contains the message, our diagnostic is ported!
More complex messages with interpolation will be able to reference other fields
in a diagnostic type (when implemented manually, those are provided as
arguments). See the diagnostic translation documentation &lt;a href&#x3D;&quot;https://rustc-dev-guide.rust-lang.org/diagnostics/translation.html&quot;&gt;in the &lt;code&gt;rustc&lt;/code&gt; dev
guide&lt;/a&gt; for more examples.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#3-porting-diagnostics&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;3-porting-diagnostics&quot;&gt;&lt;/a&gt;3. Porting diagnostics&lt;/h3&gt;
&lt;p&gt;Now that you&#x27;ve got a rough idea what to do, you need to find some diagnostics
to port. There&#x27;s lots of diagnostics to port, so the diagnostic working group
have split the work up to avoid anyone working on the same diagnostic as
someone else - but right now, there aren&#x27;t many people involved, so just pick a
crate and start porting it :)&lt;/p&gt;
&lt;p&gt;Please add the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues?q&#x3D;is%3Aopen+label%3AA-translation+sort%3Aupdated-desc&quot;&gt;&lt;code&gt;A-translation&lt;/code&gt;&lt;/a&gt; label to any pull requests that
you make so we can keep track of who has made a contribution! You can use
&lt;code&gt;rustbot&lt;/code&gt; to label your PR (if it wasn&#x27;t labelled automatically by
&lt;code&gt;triagebot&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-text&quot;&gt;@rustbot label +A-translation
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can also assign a member of the diagnostics working group to review your PR
by posting a comment with the following content (or including this in the PR
description):&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-text&quot;&gt;r? rust-lang/diagnostics
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Even if you aren&#x27;t sure exactly how to proceed, give it a go and you can ask
for help in &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/147480-t-compiler.2Fwg-diagnostics&quot;&gt;&lt;code&gt;#t-compiler/wg-diagnostics&lt;/code&gt;&lt;/a&gt; or reach out to &lt;a href&#x3D;&quot;https://github.com/davidtwco&quot;&gt;&lt;code&gt;@davidtwco&lt;/code&gt;&lt;/a&gt;.
Check out &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/100717&quot;&gt;#100717&lt;/a&gt; for guidance on where to get started!&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#faq&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;faq&quot;&gt;&lt;/a&gt;FAQ&lt;/h2&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#is-this-a-feature-that-anyone-wants&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;is-this-a-feature-that-anyone-wants&quot;&gt;&lt;/a&gt;Is this a feature that anyone wants?&lt;/h3&gt;
&lt;p&gt;Yes! Some language communities prefer native resources and some don&#x27;t (and
preferences will vary within those communities too). For example,
Chinese-speaking communities have a mature ecosystem of programming language
resources which don&#x27;t require knowing any English.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#wouldnt-translating-x-be-more-worthwhile&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;wouldnt-translating-x-be-more-worthwhile&quot;&gt;&lt;/a&gt;Wouldn&#x27;t translating X be more worthwhile?&lt;/h3&gt;
&lt;p&gt;There are many different areas within the Rust project where
internationalization would be beneficial. Diagnostics aren&#x27;t being prioritized
over any other part of the project, it&#x27;s just that there is interest within the
compiler team in supporting this feature.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#couldnt-compiler-developer-time-be-better-spent-elsewhere&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;couldnt-compiler-developer-time-be-better-spent-elsewhere&quot;&gt;&lt;/a&gt;Couldn&#x27;t compiler developer time be better spent elsewhere?&lt;/h3&gt;
&lt;p&gt;Compiler implementation isn&#x27;t zero-sum: work on other parts of the compiler
aren&#x27;t impacted by these efforts and working on diagnostic translation doesn&#x27;t
prevent contributors working on anything else.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#will-translations-be-opt-in&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;will-translations-be-opt-in&quot;&gt;&lt;/a&gt;Will translations be opt-in?&lt;/h3&gt;
&lt;p&gt;Translations will be opt-in, you won&#x27;t need to use them if you don&#x27;t want to.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#how-will-a-user-select-the-language&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;how-will-a-user-select-the-language&quot;&gt;&lt;/a&gt;How will a user select the language?&lt;/h3&gt;
&lt;p&gt;Exactly how a user will choose to use translated error messages hasn&#x27;t been
decided yet.&lt;/p&gt;
</content>

        <author>
            <name>David Wood</name>
        </author>
    </entry>
    
    <entry>
        <title>Please welcome Dan to Library Contributors</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2022/08/10/libs-contributors.html" type="text/html" title="Please welcome Dan to Library Contributors" />
        <published>2022-08-10T00:00:00+00:00</published>
        <updated>2022-08-10T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2022/08/10/libs-contributors.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2022/08/10/libs-contributors.html">&lt;p&gt;Please welcome &lt;a href&#x3D;&quot;https://github.com/sunfishcode&quot;&gt;Dan Gohman&lt;/a&gt; to the
&lt;a href&#x3D;&quot;https://www.rust-lang.org/governance/teams/library#libs-contributors&quot;&gt;Library Contributors&lt;/a&gt; group!&lt;/p&gt;
&lt;p&gt;You might know Dan from his work on
&lt;a href&#x3D;&quot;https://wasmtime.dev/&quot;&gt;Wasmtime&lt;/a&gt;, WASI, the recent &lt;a href&#x3D;&quot;https://rust-lang.github.io/rfcs/3128-io-safety.html&quot;&gt;I/O Safety RFC&lt;/a&gt;,
&lt;a href&#x3D;&quot;https://crates.io/crates/cap-std&quot;&gt;cap-std&lt;/a&gt;, &lt;a href&#x3D;&quot;https://crates.io/crates/rustix&quot;&gt;rustix&lt;/a&gt;,
or one of his many (often WASI or I/O related) contributions to the Rust standard library.&lt;/p&gt;
&lt;p&gt;Congratulations Dan, and thanks for everything you do!&lt;/p&gt;
</content>

        <author>
            <name>Mara Bos</name>
        </author>
    </entry>
    
</feed>
